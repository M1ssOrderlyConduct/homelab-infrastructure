#!/usr/bin/env python3
"""EthShare - Toggle WiFi-to-Ethernet sharing from the system tray."""

import fcntl
import os
import signal
import subprocess
import sys
import threading

LOCK_FILE = "/tmp/ethshare.lock"

import gi
gi.require_version("Gtk", "3.0")
gi.require_version("AyatanaAppIndicator3", "0.1")
from gi.repository import Gtk, AyatanaAppIndicator3, GLib

HELPER = os.path.expanduser("~/.local/share/ethshare/helper.sh")
STATE_FILE = "/tmp/ethshare.active"

ICON_ON = "network-transmit-receive"
ICON_OFF = "network-offline"


class EthShare:
    def __init__(self):
        self.sharing = False
        self.busy = False

        self.indicator = AyatanaAppIndicator3.Indicator.new(
            "ethshare",
            ICON_OFF,
            AyatanaAppIndicator3.IndicatorCategory.SYSTEM_SERVICES,
        )
        self.indicator.set_status(AyatanaAppIndicator3.IndicatorStatus.ACTIVE)

        self._check_state()
        self._rebuild_menu()

        GLib.timeout_add_seconds(10, self._poll_state)

    # -- menu --

    def _rebuild_menu(self):
        """Rebuild the entire menu - most reliable way to update AppIndicator."""
        menu = Gtk.Menu()

        if self.busy:
            toggle_label = "Applying..."
        elif self.sharing:
            toggle_label = "Disable Sharing"
        else:
            toggle_label = "Enable Sharing"

        toggle_item = Gtk.MenuItem(label=toggle_label)
        toggle_item.set_sensitive(not self.busy)
        toggle_item.connect("activate", self._on_toggle)
        menu.append(toggle_item)

        menu.append(Gtk.SeparatorMenuItem())

        status_label = "Sharing: WiFi \u2192 Ethernet" if self.sharing else "Sharing: Off"
        status_item = Gtk.MenuItem(label=status_label)
        status_item.set_sensitive(False)
        menu.append(status_item)

        ssid = self._get_wifi_ssid()
        wifi_item = Gtk.MenuItem(label=f"WiFi: {ssid}")
        wifi_item.set_sensitive(False)
        menu.append(wifi_item)

        menu.append(Gtk.SeparatorMenuItem())

        quit_item = Gtk.MenuItem(label="Quit")
        quit_item.connect("activate", self._on_quit)
        menu.append(quit_item)

        menu.show_all()
        self.indicator.set_menu(menu)

        icon = ICON_ON if self.sharing else ICON_OFF
        desc = "Sharing Active" if self.sharing else "Sharing Off"
        self.indicator.set_icon_full(icon, desc)

    # -- state --

    def _check_state(self):
        try:
            with open("/proc/sys/net/ipv4/ip_forward") as f:
                forwarding = f.read().strip() == "1"
            self.sharing = forwarding and os.path.exists(STATE_FILE)
        except OSError:
            self.sharing = False

    def _poll_state(self):
        old = self.sharing
        self._check_state()
        if old != self.sharing:
            self._rebuild_menu()
        return True

    def _get_wifi_ssid(self):
        try:
            result = subprocess.run(
                ["nmcli", "-t", "-f", "active,ssid", "dev", "wifi"],
                capture_output=True, text=True, timeout=5,
            )
            for line in result.stdout.strip().splitlines():
                if line.startswith("yes:"):
                    return line.split(":", 1)[1]
        except (subprocess.SubprocessError, OSError):
            pass
        return "\u2014"

    # -- toggle (async) --

    def _on_toggle(self, _widget):
        if self.busy:
            return
        action = "disable" if self.sharing else "enable"
        self.busy = True
        self._rebuild_menu()

        thread = threading.Thread(target=self._run_helper, args=(action,), daemon=True)
        thread.start()

    def _run_helper(self, action):
        try:
            result = subprocess.run(
                ["sudo", HELPER, action],
                capture_output=True, text=True, timeout=30,
            )
            success = result.returncode == 0
        except subprocess.SubprocessError:
            success = False

        GLib.idle_add(self._on_helper_done, success)

    def _on_helper_done(self, success):
        self.busy = False
        if success:
            self._check_state()
        self._rebuild_menu()
        return False  # run once

    # -- quit --

    def _on_quit(self, _widget):
        Gtk.main_quit()


def main():
    # Single-instance guard
    lock_fd = open(LOCK_FILE, "w")
    try:
        fcntl.flock(lock_fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
    except OSError:
        sys.exit(0)  # already running
    lock_fd.write(str(os.getpid()))
    lock_fd.flush()

    signal.signal(signal.SIGINT, signal.SIG_DFL)
    EthShare()
    Gtk.main()


if __name__ == "__main__":
    main()
